'use strict';

/* Main animation loop will be implemented here */

// Global parameters & Constants
const PARAMS = {
    SPATIAL_FREQUENCY: 0.02,    // How quickly waves change over space
    TEMPORAL_FREQUENCY: 0.025,  // How quickly waves change over time (phase shift speed)
    ANIMATION_SPEED_FACTOR: 1.0, // Multiplier for overall animation speed
};
const REMOVAL_THRESHOLD = 20; // Max distance in pixels to a node for it to be removable by right-click

// Global state variables
let currentTime = 0;        // Current animation time in seconds, adjusted by ANIMATION_SPEED_FACTOR
const activeNodes = [];     // Array to store active wave-generating nodes
let nodeIdCounter = 0;      // Simple counter for unique node IDs

// Canvas setup
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
console.log(`Canvas dimensions: ${canvas.width}x${canvas.height}`); // Initial log of canvas size

// --- Color Utilities ---

/**
 * Converts HSL color values to RGB.
 * @param {number} h Hue (0-360)
 * @param {number} s Saturation (0-1)
 * @param {number} l Lightness (0-1)
 * @returns {{r: number, g: number, b: number}} RGB color object (0-255)
 */
function hslToRgb(h, s, l) {
    let r, g, b;
    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const hueToRgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        h /= 360; // Normalize h to [0,1]
        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
    }
    return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
}

/**
 * Maps a combined wave value to an RGB color.
 * @param {number} totalWaveValue The sum of wave values from all active nodes at a pixel.
 * @param {number} numNodes The number of active nodes.
 * @param {object} colorParams (Currently unused) Additional parameters for color mapping.
 * @returns {{r: number, g: number, b: number}} RGB color object.
 */
function mapWaveValueToRGB(totalWaveValue, numNodes, colorParams = {}) {
    if (numNodes === 0) {
        return { r: 0, g: 0, b: 0 }; // Return black if there are no nodes
    }

    // Normalize the total wave value.
    // Average the wave value by dividing by the number of nodes.
    let normalizedValue = totalWaveValue / numNodes;
    // Map the result from the range [-1, 1] to [0, 1].
    normalizedValue = (normalizedValue + 1) / 2;
    // Clamp the value to ensure it's within the [0, 1] range.
    normalizedValue = Math.max(0, Math.min(1, normalizedValue));

    // Convert the normalized value to a hue (0-360 degrees).
    const hue = normalizedValue * 360;
    // Use fixed saturation and lightness for now.
    const saturation = 1.0; // Full saturation
    const lightness = 0.5;  // Mid lightness

    return hslToRgb(hue, saturation, lightness);
}

// --- Wave & Node Logic ---

/**
 * Calculates the wave value at a specific pixel generated by a single node.
 * @param {number} px Pixel's x-coordinate.
 * @param {number} py Pixel's y-coordinate.
 * @param {object} node The node object {x, y, creationTime, id}.
 * @param {number} currentTime Current animation time.
 * @param {object} params Global parameters including SPATIAL_FREQUENCY and TEMPORAL_FREQUENCY.
 * @returns {number} The wave value (-1 to 1).
 */
function calculateSingleWaveValue(px, py, node, currentTime, params) {
    const dx = px - node.x;
    const dy = py - node.y;
    // Euclidean distance from pixel to node center
    const d = Math.sqrt(dx*dx + dy*dy);
    // Phase offset based on node's creation time to make waves appear to emanate from the node
    const phaseOffset = (node.creationTime / 1000) * params.TEMPORAL_FREQUENCY; // Convert ms to s

    // Sine wave formula: d * spatial_freq - time * temporal_freq + phase_offset
    return Math.sin(d * params.SPATIAL_FREQUENCY - currentTime * params.TEMPORAL_FREQUENCY + phaseOffset);
}

/**
 * Creates and adds a new node to the activeNodes array.
 * @param {number} x The x-coordinate for the new node.
 * @param {number} y The y-coordinate for the new node.
 */
function addNode(x, y) {
    const newNode = {
        x: x,
        y: y,
        id: nodeIdCounter++,
        creationTime: Date.now() // Store creation time in milliseconds
    };
    activeNodes.push(newNode);
}

/**
 * Removes the node closest to the given click coordinates if it's within REMOVAL_THRESHOLD.
 * @param {number} clickX The x-coordinate of the click.
 * @param {number} clickY The y-coordinate of the click.
 */
function removeNode(clickX, clickY) {
    let closestNode = null;
    let minDistanceSq = Infinity; // Compare squared distances to avoid Math.sqrt

    for (const node of activeNodes) {
        const dx = clickX - node.x;
        const dy = clickY - node.y;
        const distanceSq = dx*dx + dy*dy; // Squared Euclidean distance

        if (distanceSq < minDistanceSq) {
            minDistanceSq = distanceSq;
            closestNode = node;
        }
    }

    // Check if the closest node is within the removal threshold
    if (closestNode && minDistanceSq < REMOVAL_THRESHOLD * REMOVAL_THRESHOLD) {
        const index = activeNodes.indexOf(closestNode);
        if (index > -1) { // Ensure node is found before splicing
            activeNodes.splice(index, 1);
        }
    }
}

// --- Event Listeners ---

// Add node on left click
canvas.addEventListener('click', function(event) {
    addNode(event.offsetX, event.offsetY);
});

// Remove node on right click (context menu)
canvas.addEventListener('contextmenu', function(event) {
    event.preventDefault(); // Prevent context menu from appearing
    removeNode(event.offsetX, event.offsetY);
});

// --- Rendering & Animation Loop ---

/**
 * Draws the current state of active nodes as small circles.
 * Useful for visualizing node positions on top of the wave patterns.
 */
function drawNodes() {
    // Clearing the canvas is handled by renderFrame before this function is called.
    for (const node of activeNodes) {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 5, 0, 2 * Math.PI); // 5px radius circle
        ctx.fillStyle = 'red'; // Conspicuous color for visibility
        ctx.fill();
    }
}

/**
 * Renders a single frame of the wave animation.
 * Calculates wave interference for each pixel and updates the canvas.
 */
function renderFrame() {
    // Clear the entire canvas at the beginning of each frame.
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Create an ImageData object to hold pixel data for the current frame.
    // This is done once per frame for efficiency.
    let imageData = ctx.createImageData(canvas.width, canvas.height);
    let data = imageData.data; // Direct reference to the pixel data array

    // Iterate over each pixel on the canvas.
    for (let y = 0; y < canvas.height; y++) {
        for (let x = 0; x < canvas.width; x++) {
            let totalWaveValue = 0;

            // Sum wave values from all active nodes for the current pixel.
            if (activeNodes.length > 0) {
                for (const node of activeNodes) {
                    totalWaveValue += calculateSingleWaveValue(x, y, node, currentTime, PARAMS);
                }
            }

            // Map the summed wave value to an RGB color.
            let { r, g, b } = mapWaveValueToRGB(totalWaveValue, activeNodes.length, PARAMS);

            // Calculate the index in the ImageData array for the current pixel.
            // Each pixel is represented by 4 values (R, G, B, A).
            let index = (y * canvas.width + x) * 4;

            data[index]     = r;     // Red channel
            data[index + 1] = g;     // Green channel
            data[index + 2] = b;     // Blue channel
            data[index + 3] = 255;   // Alpha channel (fully opaque)
        }
    }
    // Draw the completed ImageData onto the canvas.
    ctx.putImageData(imageData, 0, 0);
}

/**
 * Main animation loop.
 * Updates current time, renders the frame, and schedules the next frame.
 */
function gameLoop() {
    // Update current time based on high-resolution timer, scaled by animation speed factor.
    currentTime = (performance.now() / 1000) * PARAMS.ANIMATION_SPEED_FACTOR;

    renderFrame(); // Calculate and draw wave patterns.
    drawNodes();   // Optionally draw node markers on top.

    // Request the next animation frame to continue the loop.
    window.requestAnimationFrame(gameLoop);
}

// --- Initialization ---

/**
 * Initializes the application.
 * Adds a default node if the canvas is ready.
 * Starts the animation loop.
 */
function init() {
    // Add an initial node to the center of the canvas for immediate visual feedback.
    // This is helpful for users to see something happening when the page loads.
    if (activeNodes.length === 0) {
        if (canvas && canvas.width > 0 && canvas.height > 0) {
            addNode(canvas.width / 2, canvas.height / 2);
            console.log(`Initial node added at (${canvas.width / 2}, ${canvas.height / 2})`);
        } else {
            // This might happen if the script runs before the canvas is fully initialized in the DOM,
            // or if canvas dimensions are not set.
            console.warn("Canvas not ready or dimensions not set for initial node placement. Retrying in 100ms.");
            // Retry once after a short delay, in case of timing issues with DOM readiness.
            setTimeout(() => {
                if (canvas && canvas.width > 0 && canvas.height > 0) {
                    addNode(canvas.width / 2, canvas.height / 2);
                    console.log(`Initial node added at (${canvas.width / 2}, ${canvas.height / 2}) after delay.`);
                } else {
                    console.error("Canvas still not ready. Initial node not added.");
                }
            }, 100);
        }
    }
    // Start the main animation loop.
    window.requestAnimationFrame(gameLoop);
}

// Start the application
init();
